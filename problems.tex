\documentclass[a4paper,12pt]{article}



\usepackage[export]{adjustbox}
\usepackage[russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}



\usepackage{amsbsy}
\usepackage{amscd}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsopn}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsthm}
\usepackage{amsxtra}
\usepackage{array}
\usepackage{ctable}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{latexsym}
\usepackage{listings}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{xcolor}



\renewcommand{\familydefault}{\sfdefault}

\renewcommand{\arraystretch}{1.5}

\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\geometry{left   = 0.5cm}
\geometry{bottom = 0.5cm}
\geometry{right  = 0.5cm}
\geometry{top    = 0.5cm}

\parindent = 0pt
\parskip   = 0pt
\tolerance = 100

\flushbottom

\definecolor{G}{rgb}{0.00, 0.50, 0.00}

\hypersetup
{
    linkcolor  = G,
    urlcolor   = G,
    colorlinks = true
}

\renewenvironment{itemize}
{
    \begin{list}{\labelitemi}
    {
      \setlength{\topsep}{0pt}
      \setlength{\partopsep}{0pt}
      \setlength{\parskip}{0pt}
      \setlength{\itemsep}{0pt}
      \setlength{\parsep}{0pt}
      \setlength{\leftmargin}{14.5pt}
    }
}{\end{list}}

\definecolor{B}{rgb}{0.00, 0.00, 0.50}

\lstset
{
    backgroundcolor   = \color{white},      % Установка цвета заднего плана  
    basicstyle        = \ttfamily\color{B}, % Установка размера и цвета шрифта
    breakatwhitespace = true,               % Установка разрывов на пробелах
    breaklines        = true,               % Установка переноса длинных строк
    captionpos        = none,               % Установка позиции имени листинга
    commentstyle      = \color{B},          % Установка цвета комментариев кода
    deletekeywords    = {},                 % Установка удаленных ключевых слов  
    escapeinside      = {\%*}{*)},          % Установка добавления LaTeX в коде  
    extendedchars     = false,              % Установка дополнительных символов 
    frame             = L,                  % Установка типа рамки вокруг кода
    framexleftmargin  = -8pt,               % Установка размера левого отступа
    keepspaces        = true,               % Установка выравнивания пробелов
    keywordstyle      = \color{B},          % Установка цвета ключевых слов  
    language          = C++,                % Установка языка программирования
    otherkeywords     = {},                 % Установка добавочных ключевых слов   
    numbers           = none,               % Установка позиции нумерации строк
    numbersep         = 0pt,                % Установка отступа нумерации строк
    numberstyle       = \color{black},      % Установка цвета нумерации строк
    showspaces        = false,              % Установка пробелов символом '_'
    showstringspaces  = false,              % Установка пробелов символом '_'
    showtabs          = false,              % Установка табуляторов видимыми
    stepnumber        = 1,                  % Установка периода нумерации строк
    stringstyle       = \color{B},          % Установка цвета строковых литералов
    tabsize           = 2,                  % Установка размера табуляции в коде
}



\begin{document}



\newpage\thispagestyle{empty}\pdfpageheight = 2.50in\enlargethispage{100in}

\title{\bf Software Engineering} 

\author{Moscow Institute of Physics and Technology}

\date{}

\maketitle



\newpage\thispagestyle{empty}\pdfpageheight = 6.10in\enlargethispage{100in}

\renewcommand\contentsname{\Large Table of Contents}

\renewcommand{\cftdotsep}{0.5}

\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\makeatletter
\let\latexl@section\l@section
\def\l@section#1#2{\begingroup\let\numberline\@gobble\latexl@section{#1}{#2}\endgroup}
\makeatother

\titlelabel{}

%\thispagestyle{empty}\tableofcontents\thispagestyle{empty}



\newpage\thispagestyle{empty}\pdfpageheight = 4.20in

\textbf{\Large 00. Mandatory Requirements}

\bigskip

\,\textbf{Требования: часть 1}

\medskip

\begin{itemize}

    \item Ваши решения должны собираться без предупреждений с флагами\;-Wall,\;-Wextra\;и\;-Wpedantic.

    \smallskip

    \item Ваши решения должны сопровождаться тестами\:и\:демонстрационными\:примерами.

    \smallskip

    \item Ваши решения должны выполняться\;до\;конца\;и\;проходить\;тесты\;без\;ошибок\;и\;неопределенного\;поведения.

    \smallskip

    \item Ваши решения должны располагаться\;каждое\;в\;отдельном\;единственном\;файле\;исходного\;кода.

    \smallskip

    \item Ваши решения должны быть адекватно отформатированы в рамках единого стиля.
    
\end{itemize}

\bigskip

\,\textbf{Требования: часть 2}

\medskip

\begin{itemize}

    \item Ваши решения не должны содержать символы,\;не\;представленные\;в\;таблице\;семибитного\:стандарта\:ASCII.

    \smallskip

    \item Ваши решения не должны содержать магические\;литералы и непонятные\;названия.

    \smallskip

    \item Ваши решения не должны содержать неинициализированные\,переменные\,и\,глобальные\,объекты.

    \smallskip

    \item Ваши решения не должны содержать дублирующийся код и неиспользуемые части.

    \smallskip

    \item Ваши решения не должны содержать избыточного использования стандартных\,потоков\,для\,ввода\,и\,вывода.

\end{itemize}

\bigskip

\,В случае конфликтов требований в приоритете является выполнение требований, указанных в условиях задач.



\newpage\thispagestyle{empty}\pdfpageheight = 5.25in

\section{01. Introduction and Overview}

{\large \textbf{01.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/06.07.cpp}{06.07}\,)}} 

\bigskip

Напишите программу, которая выводит любую строку в окно терминала через стандартный поток \lstinline{std::cout} и при этом обладает функцией \lstinline{main} с единственной инструкцией \lstinline{return 0}. Предложите по крайней мере четыре разных решения. Впервые я столкнулся с этой задачей на техническом собеседовании в крупную российскую компанию. Для ее решения Вам потребуются технологии, которые будут рассматриваться во втором, третьем и шестом модулях данного курса, поэтому Вы можете пропустить эту задачу и вернуться к ней позже. Возможно, Вы немного удивились тому, что первая же задача данного курса обладает настолько неадекватным уровнем сложности. Это своеобразная дань памяти моему детству. Я начал серьезно изучать компьютерные науки и языки программирования в 12 лет, когда проводил летние школьные каникулы на даче у бабушки с дедушкой. Родители подарили мне две книги: Программирование -- принципы и практика с использованием C\texttt{++} Бьёрна Страуструпа и Язык программирования C Брайана Кернигана и Денниса Ритчи. Также у меня имелся простой ноутбук со средой разработки Code::Blocks, однако не было ни интернета, ни даже мобильной связи, потому что дача находится в низине, а сеть можно поймать только на определенном тайном холмике в лесу. Я решил начать изучение с визуально небольшой книги по языку C, быстро проработать ее, а потом приступить к монографии Страуструпа. Опрометчивое решение! В одном из первых заданий просили написать программу, которая удалила бы все комментарии из исходного кода другой программы на языке C. Предположу, что это весьма сложная задача для третьего дня изучения программирования, но я справился, потому что из-за отсутствия связи с внешним миром я просто не понял, что это сложно. Возможно, именно этот случай помог мне определиться с основным направлением всей дальнейшей деятельности. Любопытно, что случилось, если бы мне тогда подарили монографию Искусство программирования Дональда Кнута? Возможно, я стал бы лучше относиться к математике. Пожалуй, стоит провести небольшой эксперимент над собственными детьми.



\newpage\thispagestyle{empty}\pdfpageheight = 17.70in\enlargethispage{100in}

\section{02. Basics of Programming}

{\large \textbf{02.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.12.cpp}{02.12}\,)}}

\bigskip

Реализуйте алгоритм вычисления N\,-\,ого числа ряда Фибоначчи на основе формулы Бине. Используйте тип \lstinline{double} для промежуточных вычислений и тип \lstinline{int} для конечного значения числа ряда Фибоначчи. Используйте оператор \lstinline{static_cast} для преобразования округленного приближенного значения формулы Бине типа \lstinline{double} к конечному значению типа \lstinline{int}. Используйте константы для значений в формуле Бине. Используйте стандартные функции \lstinline{std::sqrt}, \lstinline{std::pow} и \lstinline{std::round}. Обоснуйте формулу Бине. Используйте стандарт- ный поток \lstinline{std::cin} для ввода через терминал номера N. Используйте стандартный поток \lstinline{std::cout} для вывода через терминал N\,-\,ого числа ряда Фибоначчи. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.02} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.17.cpp}{02.17}\,)}}

\bigskip

Реализуйте алгоритм вычисления корней алгебраического уравнения второй степени с коэффициентами a, b и c типа \lstinline{double}. Используйте ветвления \lstinline{if} для проверки значения коэффициента a и значения дискриминанта. Используйте константу epsilon и стандартную функцию \lstinline{std::abs} для корректного сравнения чисел типа \lstinline{double} с заданной точностью. Допускайте появление отрицательного нуля. Используйте стандартный поток \lstinline{std::cin} для ввода через терминал коэффициентов a, b и c. Используйте стандартный поток \lstinline{std::cout} для вывода через терминал всех корней этого уравнения. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.03} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.18.cpp}{02.18}\,)}}

\bigskip

Реализуйте алгоритм классификации символов типа \lstinline{char} из таблицы ASCII с десятичными кодами от 32 до 127 включительно на пять следующих классов: заглавные буквы, строчные буквы, десятичные цифры, знаки препинания, прочие символы. Используйте ветвление \lstinline{switch} с проваливанием и символьными литералами типа \lstinline{char} в качестве меток в секциях \lstinline{case}. Протестируйте нестандартное расширение компилятора g\texttt{++} для диапазонов и флаг компилятора -Wpedantic. Используйте секцию \lstinline{default} для пятого класса. Используйте стандартный поток \lstinline{std::cin} для ввода через терминал символов. Используйте стандартный поток \lstinline{std::cout} для вывода через терминал всех названий классов. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.04} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.20.cpp}{02.20}\,)} \texttt{//} M. Bancila, The Modern C\texttt{++} Challenge}

\bigskip

Реализуйте алгоритм вычисления всех трехзначных чисел Армстронга. Используйте тройной вложенный цикл \lstinline{for} для перебора. Не используйте стандартную функцию \lstinline{std::pow}. Используйте стандартный поток \lstinline{std::cout} для вывода через терминал всех чисел Армстронга. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.05} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.24.cpp}{02.24}\,)}}

\bigskip

Реализуйте алгоритмы вычисления числа $\pi$ на основе суммы членов ряда Лейбница и числа $e$ на основе суммы членов ряда Маклорена при x равном 1 с точностью, заданной числом epsilon. Используйте тип \lstinline{double} для промежуточных вычислений и конечных значений чисел $\pi$ и $e$. Используйте циклы \lstinline{while} для вычисления членов рядов Лейбница и Маклорена до тех пор, пока очередной член каждого ряда не станет меньше заданного пользователем числа epsilon. Не вычисляйте факториалы в знаменателях членов ряда Маклорена, чтобы избежать проблемы переполнения. Используйте известное соотношение между членами ряда Маклорена для оптимизации вычисления каждого нового члена ряда на основе предыдущего члена ряда. Используйте стандартный поток \lstinline{std::cin} для ввода через терминал числа epsilon. Используйте стандартный поток \lstinline{std::cout} для вывода через терминал вычисленных чисел $\pi$ и $e$. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.06} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.29.cpp}{02.29}\,)}}

\bigskip

Реализуйте алгоритмы вычисления максимального и минимального значений, медианы, среднего арифметического и стандартного отклонения коллекции чисел типа \lstinline{double}. Используйте встроенный статический массив для хранения и обработки коллекции чисел. Используйте стандартный поток \lstinline{std::cin} для ввода через терминал коллекции чисел. Используйте любой удобный для Вас способ ввода коллекции чисел, например, с предварительным вводом размера коллекции чисел. Реализуйте алгоритм сортировки пузырьком как дополнительную часть алгоритма вычисления медианы коллекции чисел. Используйте стандартный поток \lstinline{std::cout} для вывода через терминал максимального и минимального значений, медианы, среднего арифметического, а также стандартного отклонения коллекции чисел. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.07} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.30.cpp}{02.30}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 02.06 таким образом, чтобы реализация использовала встроенный динамический массив вместо встроенного статического массива. Предполагайте, что размер коллекции чисел неизвестен. Реализуйте алгоритм увеличения емкости встроенного динамического массива в процессе его использования. Реализуйте выделение нового блока памяти размером в два раза больше предыдущего, копирование всех данных из предыдущего блока памяти в новый и освобождение предыдущего блока памяти.

\bigskip

{\large \textbf{02.08} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.31.cpp}{02.31}\,)} \texttt{//} M. Bancila, The Modern C\texttt{++} Challenge}

\bigskip

Реализуйте алгоритм вычисления наибольшей длины последовательности Коллатца среди всех последовательностей, начинающихся со значений от 1 до 100. Используйте тип \lstinline{unsigned long long int} для значений последовательностей Коллатца и стандартный тип \lstinline{std::size_t} для их длин. Используйте стандартный контейнер \lstinline{std::vector} для кэширование длин последовательностей Коллатца и оптимизации вычисления длины каждой новой последовательности на основе предыдущих последовательностей. Используйте стандартный поток \lstinline{std::cout} для вывода через терминал наибольшей длины последовательности Коллатца среди рассмот- 

ренных, а также значения, с которого она начинается. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.09} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.43.cpp}{02.43}\,)} \texttt{//} M. Bancila, The Modern C\texttt{++} Challenge}

\bigskip

Реализуйте алгоритмы вычисления наибольшего общего делителя двух натуральных чисел типа \lstinline{int} на основе рекурсивного и итративного подходов, а также алгоритм вычисления наименьшего общего кратного двух натуральных чисел типа \lstinline{int}. Используйте стандартные функции \lstinline{std::gcd} и \lstinline{std::lcm} для валидации результатов.

\bigskip

{\large \textbf{02.10} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.44.cpp}{02.44}\,)}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.44.cpp}{\texttt{02.44}} таким образом, чтобы реализация использовала алгоритм быстрой сортировки вместо алгоритма сортировки слиянием. Реализуйте метод Хоара. Используйте медиану первого, среднего и последнего элементов как опорный элемент. Обоснуйте временную сложность данного алгоритма сортировки.



\newpage\thispagestyle{empty}\pdfpageheight = 23.70in\enlargethispage{100in}

\section{03. Object\,-\,Oriented Programming}

{\large \textbf{03.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.02.cpp}{03.02}\,)}}

\bigskip

Реализуйте структуру \lstinline{Rectangle} для представления прямоугольников со сторонами, которые параллельны осям координатной плоскости. Реализуйте в структуре \lstinline{Rectangle} четыре поля типа \lstinline{int} для хранения координат левого верхнего и правого нижнего углов прямоугольника. Используйте систему координат, в которой ось абсцисс направлена вправо, а ось ординат направлена вниз. Реализуйте алгоритм вычисления площади пересечения нескольких прямоугольников. Рассмотрите случаи пустого и вырожденного пересечения прямоуголь- 

ников. Реализуйте алгоритм вычисления наименьшего ограничивающего несколько прямоугольников прямоу-

гольника. Используйте стандартный контейнер \lstinline{std::vector} для хранения экземпляров структуры \lstinline{Rectangle}.

\bigskip

{\large \textbf{03.02} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.04.cpp}{03.04}\,)}}

\bigskip

Реализуйте класс \lstinline{Circle} для представления окружностей. Реализуйте в классе \lstinline{Circle} приватное поле типа \lstinline{double} для хранения радиуса. Реализуйте класс \lstinline{Triangle} для представления треугольников. Реализуйте в классе \lstinline{Triangle} три приватных поля типа \lstinline{double} для хранения длин трех сторон. Реализуйте класс \lstinline{Square} для представления квадратов. Реализуйте в классе \lstinline{Square} приватное поле типа \lstinline{double} для хранения длины одной стороны. Реализуйте в классах \lstinline{Circle}, \lstinline{Triangle} и \lstinline{Square} необходимые пользовательские конструкторы и публичные функции-члены \lstinline{perimeter} и \lstinline{area} для вычисления периметра и площади соответственно. Используйте стандартную константу \lstinline{std::numbers::pi} в функциях-членах \lstinline{perimeter} и \lstinline{area} класса \lstinline{Circle}.

\bigskip

{\large \textbf{03.03} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.05.cpp}{03.05}\,)}}

\bigskip

Реализуйте класс \lstinline{List} для представления односвязного списка. Реализуйте структуру \lstinline{Node} для представления узлов односвязного списка как приватную вложенную структуру в классе \lstinline{List}. Реализуйте в структуре \lstinline{Node} поле типа \lstinline{int} для хранения значения текущего узла списка и указатель типа \lstinline{Node *} для хранения адреса следующего узла списка. Реализуйте в классе \lstinline{List} два приватных указателя типа \lstinline{Node *} для хранения адресов первого и последнего узлов списка. Не создавайте в классе \lstinline{List} поле для хранения текущего размера списка и пользовательские конструкторы. Реализуйте в классе \lstinline{List} публичную функцию-член \lstinline{empty} для проверки наличия хотя бы одного узла в списке. Реализуйте в классе \lstinline{List} публичную функцию-член \lstinline{show} для вывода значений всех текущих узлов списка в окно терминала через стандартный поток \lstinline{std::cout}. Реализуйте в классе \lstinline{List} публичные функции-члены \lstinline{push_front} и \lstinline{push_back} для вставки новых узлов с пользовательскими значениями в начало и в конец списка соответственно. Используйте оператор \lstinline{new} для динамического выделения памяти. Реализуйте в классе \lstinline{List} публичные функции-члены \lstinline{pop_front} и \lstinline{pop_back} для удаления узлов из начала и из конца списка соответственно. Используйте оператор \lstinline{delete} для освобождения памяти. Реализуйте в классе \lstinline{List} публичную функцию-член \lstinline{get} для получения значения текущего среднего узла списка. Используйте только один цикл для обхода списка в функции-члене \lstinline{get}~класса~\lstinline{List}.~Реализуйте~в~классе~\lstinline{List} 

пользовательский деструктор, который корректно освободит память, выделенную при создании узлов списка. 

Выполните модульное и интеграционное тестирование для всех реализованных функций-членов класса \lstinline{List}.

\bigskip

{\large \textbf{03.04} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.09.cpp}{03.09}\,)}}

\bigskip

Реализуйте систему внешнего тестирования приватных функций-членов некоторого класса. Реализуйте класс \lstinline{Entity}. Реализуйте в классе \lstinline{Entity} приватные функции-члены \lstinline{test_v1} и \lstinline{test_v2}, которые необходимо протестировать. Вспомните о первом принципе SOLID - принципе единственности ответственности. Реализуйте 

дружественные для класса \lstinline{Entity} классы \lstinline{Tester_v1} и \lstinline{Tester_v2} для представления тестировщиков функций-членов \lstinline{test_v1} и \lstinline{test_v2} класса \lstinline{Entity} соответственно, чтобы получить прямой доступ к приватной секции класса \lstinline{Entity} и устранить использование публичного интерфейса класса \lstinline{Entity}. Используйте паттерн Attorney\,-\,Client для ограничения доступа классов \lstinline{Tester_v1} и \lstinline{Tester_v2} к приватной секции класса \lstinline{Entity}.

\bigskip

{\large \textbf{03.05} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.16.cpp}{03.16}\,)} \texttt{//} H. Sutter, Exceptional C\texttt{++}}

\bigskip

Реализуйте систему раздельного переопределения множественно наследуемых виртуальных функций-членов с одинаковыми сигнатурами и разными реализациями. Реализуйте базовые классы \lstinline{Entity_v1} и \lstinline{Entity_v2}. Реализуйте в классах \lstinline{Entity_v1} и \lstinline{Entity_v2} виртуальные функции-члены \lstinline{test} с одинаковыми сигнатурами и разными реализациями. Реализуйте производный класс \lstinline{Client}, который является наследником интерфейсов классов \lstinline{Entity_v1} и \lstinline{Entity_v2}. Обратите внимание, что раздельное переопределение наследуемых виртуальных функций-членов \lstinline{test} в классе \lstinline{Client} невозможно из-за совпадения их сигнатур. Реализуйте производные классы \lstinline{Adapter_v1} и \lstinline{Adapter_v2} для представления посредников, которые являются наследниками интерфейсов классов \lstinline{Entity_v1} и \lstinline{Entity_v2} соответственно. Реализуйте производный класс \lstinline{Client}, который является наследником интерфейсов классов \lstinline{Adapter_v1} и \lstinline{Adapter_v2}. Реализуйте в классах \lstinline{Adapter_v1} и \lstinline{Adapter_v2} виртуальные функции-члены \lstinline{test_v1} и \lstinline{test_v2} соответственно, которые вызываются из переоп- 

ределенных наследуемых виртуальных функций-членов \lstinline{test} и раздельно переопределяются в классе \lstinline{Client}.

\bigskip

{\large \textbf{03.06} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.17.cpp}{03.17}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 03.02 таким образом, чтобы реализация использовала иерархию классов геометрических фигур вместо отдельных классов. Реализуйте абстрактный базовый класс \lstinline{Shape} для представления интерфейса геометрических фигур. Реализуйте в классе \lstinline{Shape} виртуальный деструктор и публичные чисто виртуальные функции-члены \lstinline{perimeter} и \lstinline{area} для вычисления периметра и площади соответственно. Реализуйте производный класс \lstinline{Circle} для представления окружностей, который является наследником интерфейса класса \lstinline{Shape}. Реализуйте производный абстрактный базовый класс \lstinline{Polygon} для представления многоугольников, который является наследником интерфейса класса \lstinline{Shape}. Реализуйте производные классы \lstinline{Triangle} и \lstinline{Rectangle} для представления треугольников и прямоугольников соответственно, которые являются наследниками интерфейса класса \lstinline{Polygon}. Реализуйте производный класс \lstinline{Square} для представления квадратов, который является наследником интерфейса класса \lstinline{Rectangle}. Не создавайте в классе \lstinline{Square} поле для хранения длины стороны квадрата. Реализуйте в классе \lstinline{Square} только пользовательский конструктор, который передает аргументы конструктору класса \lstinline{Rectangle}. Используйте спецификатор \lstinline{override} при переопределении наследуемых виртуальных функций-членов \lstinline{perimeter} и \lstinline{area} в классах \lstinline{Circle}, \lstinline{Triangle} и \lstinline{Rectangle}. Используйте спецификатор \lstinline{final} для запрета наследования от классов \lstinline{Circle} и \lstinline{Square} и для запрета переопределения наследуемых виртуальных функций-членов \lstinline{perimeter} и \lstinline{area} в наследниках класса \lstinline{Rectangle}. Используйте стандартный контейнер \lstinline{std::vector} для хранения экземпляров классов \lstinline{Circle}, \lstinline{Triangle} и \lstinline{Square} через указатели на класс \lstinline{Shape}. Продемонстрируйте работу динамического полиморфизма.

\bigskip

{\large \textbf{03.07} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.30.cpp}{03.30}\,)}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.30.cpp}{\texttt{03.30}} таким образом, чтобы пользователь мог вставлять произвольное количество новых элементов в вектор, используя автоматическое увеличение емкости его встроенного динамического массива при нехватке свободных ячеек памяти. Реализуйте в классе \lstinline{Vector} два приватных поля стандартного типа \lstinline{std::size_t} для хранения значений емкости и размера. Реализуйте в классе \lstinline{Vector} публичные функции-члены \lstinline{capacity} и \lstinline{size} для получения значений емкости и размера вектора соответственно. Реализуйте в классе \lstinline{Vector} публичную функцию-член \lstinline{push_back} для вставки нового элемента в первую свободную ячейку памяти вектора с возможностью увеличения емкости его встроенного динамического массива в случае нехватки свободных ячеек памяти. Используйте алгоритм увеличения емкости встроенного динамического массива из Вашего предыдущего решения задачи 02.07. Реализуйте в классе \lstinline{Vector} публичную функцию-член \lstinline{clear} для удаления всех элементов вектора без выполнения освобождения выделенных для них ячеек памяти. Реализуй- 

те в классе \lstinline{Vector} публичную функцию-член \lstinline{empty} для проверки наличия хотя бы одного элемента в векторе.

\bigskip

{\large \textbf{03.08} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.31.cpp}{03.31}\,)}}

\bigskip

|

\bigskip

{\large \textbf{03.09} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.32.cpp}{03.32}\,)} \texttt{//} M. Bancila, The Modern C\texttt{++} Challenge}

\bigskip

Реализуйте класс \lstinline{IPv4} для представления IP адресов в стандарте IPv4. Реализуйте~в~классе~\lstinline{IPv4}~приватный 

стандартный контейнер \lstinline{std::array} из четырех элементов стандартного типа \lstinline{std::uint8_t} для хранения IP 

адресов. Реализуйте в классе \lstinline{IPv4} перегруженные операторы префиксного и постфиксного инкремента и декремента IP адресов. Реализуйте дружественные для класса \lstinline{IPv4} перегруженные операторы сравнения, ввода и вывода IP адресов. Используйте стандартный поток \lstinline{std::stringstream} для ввода через строку IP адресов в формате четырех целых чисел от 0 до 255 включительно, разделенных точками. Используйте стандартный поток \lstinline{std::stringstream} для вывода через строку IP адресов в формате, который использовался для ввода.

\bigskip

{\large \textbf{03.10} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.34.cpp}{03.34}\,)}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.32.cpp}{\texttt{03.32}} таким образом, чтобы реализация использовала перегруженный оператор трехстороннего сравнения, переписывание выражений и перегруженный оператор сравнения на равенство вместо шести перегруженных операторов сравнения. Реализуйте дружественные для класса \lstinline{Rational} перегруженные 

операторы трехстороннего сравнения и сравнения на равенство. Используйте сильный порядок при сравнении.



\newpage\thispagestyle{empty}\pdfpageheight = 18.30in\enlargethispage{100in}

\section{04. Generic Programming}

{\large \textbf{04.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.01.cpp}{04.01}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 02.10 таким образом, чтобы реализация использовала тип \lstinline{T} в качестве типа сортируемых данных вместо типа \lstinline{int}. Предполагайте, что для типа \lstinline{T} определены все необходимые операции. Используйте шаблоны функций. Не изменяйте детали реализации алгоритма сортировки.

\bigskip

{\large \textbf{04.02} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.06.cpp}{04.06}\,)} \texttt{//} M. Bancila, The Modern C\texttt{++} Challenge}

\bigskip

Реализуйте алгоритмы вычисления максимального и минимального значений, суммы и среднего арифметического пакета аргументов типа \lstinline{double}. Используйте вариативные шаблоны функций. Используйте рекурсивное инстанцирование вариативных шаблонов функций при вычислении максимального и минимального значений пакета. Используйте выражения свертки при вычислении суммы и среднего арифметического пакета. Используйте оператор \lstinline{sizeof...} для определения количества аргументов при вычислении среднего арифметического пакета. Предполагайте, что пакет содержит только аргументы типа \lstinline{double}, при этом их количество ненулевое.

\bigskip

{\large \textbf{04.03} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.07.cpp}{04.07}\,)} \texttt{//} M. Bancila, The Modern C\texttt{++} Challenge}

\bigskip

Реализуйте алгоритм вставки пакета аргументов типа \lstinline{int} в произвольный контейнер, обладающий публичной функцией-членом \lstinline{push_back}. Используйте вариативный шаблон функции. Используйте выражение свертки. Используйте оператор запятая в качестве бинарного оператора в выражении свертки. Предполагайте, что пакет может содержать аргументы других типов, которые следует игнорировать. Реализуйте перегруженный шаблон функции \lstinline{handle} для вставки аргументов типа \lstinline{int} в произвольный контейнер посредством функции-члена \lstinline{push_back} и игнорирования других аргументов. Используйте\:стандартный\:контейнер\:\lstinline{std::vector}\:для\:тестов.

\bigskip

{\large \textbf{04.04} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.08.cpp}{04.08}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 03.10 таким образом, чтобы реализация использовала тип \lstinline{T} в качестве типов числителя и знаменателя дроби вместо типа \lstinline{int}. Предполагайте, что для типа \lstinline{T} определе-

ны все необходимые операции. Используйте шаблон класса. Не изменяйте детали реализации класса \lstinline{Rational}.

\bigskip

{\large \textbf{04.05} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.17.cpp}{04.17}\,)}}

\bigskip

Реализуйте алгоритм вычисления N\,-\,ого числа ряда Фибоначчи на основе рекурсивного подхода. Используйте метапрограммирование шаблонов. Реализуйте базовый шаблон структуры \lstinline{Fibonacci} для представления N\,-\,ого числа ряда Фибоначчи. Реализуйте в шаблоне структуры \lstinline{Fibonacci} параметр типа \lstinline{int} для указания номера N на этапе компиляции. Реализуйте в структуре \lstinline{Fibonacci} статическое константное поле типа \lstinline{int} для хранения вычисляемого на этапе компиляции N\,-\,ого числа ряда Фибоначчи. Реализуйте в структуре \lstinline{Fibonacci} статическое утверждение \lstinline{static_assert} для проверки переполнения типа \lstinline{int} при вычислениях на этапе компиляции. Реализуйте две полные специализации шаблона структуры \lstinline{Fibonacci} для представления первого и второго чисел ряда Фибоначчи. Реализуйте шаблон константы для сокращения записей обращений 

к полю шаблона структуры \lstinline{Fibonacci}. Реализуйте альтернативный алгоритм вычисления N\,-\,ого числа ряда Фибоначчи на основе шаблонов констант. Реализуйте тесты на основе статических утверждений \lstinline{static_assert}.

\bigskip

{\large \textbf{04.06} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.19.cpp}{04.19}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 02.05 таким образом, чтобы реализация использовала вычисления на этапе компиляции вместо вычислений на этапе выполнения. Реализуйте мгновенные функции со спецификатором \lstinline{consteval} для вычисления чисел $\pi$ и $e$ на этапе компиляции. Используйте стандартный контейнер \lstinline{std::array} со спецификатором \lstinline{constexpr} для хранения различных значений числа epsilon. Не изменяйте детали реализации алгоритмов. Реализуйте тесты на основе статических утверждений \lstinline{static_assert}.

\bigskip

{\large \textbf{04.07} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.21.cpp}{04.21}\,)}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.21.cpp}{\texttt{04.21}} таким образом, чтобы пользователь мог вычитать, умножать и делить дроби на этапе компиляции. Реализуйте шаблоны структур \lstinline{Sub}, \lstinline{Mul} и \lstinline{Div} по аналогии с шаблоном структуры \lstinline{Sum} для представления операций вычитания, умножения и деления дробей соответственно. Используйте в структурах \lstinline{Sub} и \lstinline{Div} структуры \lstinline{Sum} и \lstinline{Mul} соответственно для устранения дублирования кода. Реализуйте в структурах \lstinline{Sum} и \lstinline{Mul} алгоритмы сокращения дробей. Используйте стандартную функцию \lstinline{std::gcd}. Реализуйте в структуре \lstinline{Div} статическое утверждение \lstinline{static_assert} для проверки деления на ноль при вычислениях на этапе компиляции. Реализуйте шаблоны псевдонимов для сокращения записей обращений к псевдонимам типов в шаблонах структур \lstinline{Sub}, \lstinline{Mul} и \lstinline{Div} по аналогии с шаблоном псевдонима \lstinline{sum}. Реализуйте шаблон перегруженного оператора вычитания интервалов со спецификатором \lstinline{constexpr}, используя внутри него шаблон перегру-

женного\,оператора\,сложения\,интервалов.\,Реализуйте\,тесты\,на\,основе\,статических\,утверждений\,\lstinline{static_assert}.

\bigskip

{\large \textbf{04.08} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.22.cpp}{04.22}\,)}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.22.cpp}{\texttt{04.22}} таким образом, чтобы пользователь мог использовать кортеж на этапе компиляции. Добавьте основному конструктору и шаблону функции-члена \lstinline{get} класса \lstinline{Tuple} спецификатор \lstinline{constexpr}. Реализуйте в классе \lstinline{Tuple} публичную функцию-член \lstinline{size} со спецификатором \lstinline{constexpr} для получения значения размера кортежа. Используйте оператор \lstinline{sizeof...} для определения размера пакета параметров шаблона класса \lstinline{Tuple} в функции-члене \lstinline{size}. Реализуйте тесты на основе статических утверждений \lstinline{static_assert}.

\bigskip

{\large \textbf{04.09} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.24.cpp}{04.24}\,)}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.24.cpp}{\texttt{04.24}} таким образом, чтобы пользователь мог проверять наличие некоторого заданного типа в очереди. Реализуйте базовый шаблон структуры \lstinline{Has}, а также две частичные специализации для пустой и непустой очередей соответственно по аналогии с шаблоном класса \lstinline{Max_Type}. Используйте стандартный шаб- 

лон свойств \lstinline{std::is_same} для сравнения типов. Реализуйте шаблон константы для сокращения записей обра- 

щений к полю шаблона структуры \lstinline{Has}. Реализуйте тесты на основе статических утверждений \lstinline{static_assert}.

\bigskip

{\large \textbf{04.10} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.35.cpp}{04.35}\,)}}

\bigskip

Реализуйте шаблон свойств \lstinline{is_class} по аналогии со стандартным шаблоном свойств \lstinline{std::is_class}. Не добавляйте проверку на основе стандартного шаблона свойств \lstinline{std::is_union} в собственную реализацию шаблона свойств \lstinline{is_class}. Объясните концепцию указателя на член класса в реализации стандартного шаблона свойств \lstinline{std::is_class}. Реализуйте метафункции \lstinline{add_const} и \lstinline{remove_const} по аналогии со стандартными метафункциями \lstinline{std::add_const} и \lstinline{std::remove_const} соответственно. Реализуйте метафункцию \lstinline{decay} по аналогии со стандартной метафункцией \lstinline{std::decay}. Реализуйте метафункцию \lstinline{conditional} по аналогии со стандартной метафункцией \lstinline{std::conditional}. Реализуйте шаблоны псевдонимов и шаблоны переменных для всех шаблонов свойств и метафункций. Реализуйте тесты на основе статических утверждений \lstinline{static_assert}.



\newpage\thispagestyle{empty}\pdfpageheight = 8.80in\enlargethispage{100in}

\section{05. Software Design Patterns}

{\large \textbf{05.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/05.01.cpp}{05.01}\,)}}

\bigskip

Реализуйте такую разновидность паттерна Builder, которая позволяет выполнять поэтапное создание составного объекта следующим образом: \lstinline{auto person = builder.name("Ivan").age(25).grade(10).get()}, где \lstinline{person} является указателем на экземпляр класса \lstinline{Person}, а \lstinline{builder} является экземпляром класса \lstinline{Builder}. Реализуйте класс \lstinline{Person} для представления составного объекта. Реализуйте класс \lstinline{Builder} для представления процесса создания составного объекта. Реализуйте в классе \lstinline{Builder} конструктор по умолчанию для создания составного объекта в начальном состоянии. Реализуйте в классе \lstinline{Builder} публичные функции-члены для создания составного объекта и публичную функцию-член \lstinline{get} для получения указателя на составной объект.

\bigskip

{\large \textbf{05.02} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/05.10.cpp}{05.10}\,)}}

\bigskip

Реализуйте такую разновидность паттерна Decorator, которая основана на шаблоне. Реализуйте шаблон производного класса \lstinline{Decorator}, который является наследником интерфейса класса \lstinline{Entity} и наследником реализации собственного параметра шаблона. Используйте класс \lstinline{Entity} как виртуальный базовый класс, чтобы предотвратить неоднозначности выбора. Устраните в классе \lstinline{Decorator} конструктор и ссылку на класс \lstinline{Entity}.

\bigskip

{\large \textbf{05.03} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/05.16.cpp}{05.16}\,)}}

\bigskip

Реализуйте систему программного каркаса для некоторой абстрактной стратегической компьютерной игры. Используйте по крайней мере один порождающий паттерн проектирования, например, Builder, для контроля над созданием игровых объектов; один структурый паттерн проектирования, например, Composite, для организации взаимодействия игровых объектов и один поведенческий паттерн проектирования, например, Template 

Method, для управления поведением игровых объектов в системе. Используйте любые другие паттерны проекти- рования при необходимости. Поставьте себя на место архитектора или инженера данной программной системы.

\bigskip

{\large \textbf{05.04} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/05.17.cpp}{05.17}\,)}}

\bigskip

Реализуйте такую разновидность паттерна Strategy, которая основана на статическом полиморфизме. Устраните класс \lstinline{Strategy}. Реализуйте шаблон производного класса \lstinline{Entity}, который является наследником реализации собственного параметра шаблона. Устраните в классе \lstinline{Entity} конструктор и ссылку на класс \lstinline{Strategy}.

\bigskip

{\large \textbf{05.05} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/05.21.cpp}{05.21}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 04.04 таким образом, чтобы реализация использовала миксины для подмешивания некоторых дополнительных операторов вместо определения всех операторов непосредственно внутри дроби. Реализуйте шаблоны базовых классов \lstinline{addable}, \lstinline{subtractable}, \lstinline{multipliable}, \lstinline{dividable}, \lstinline{incrementable} и \lstinline{decrementable} для представления подмешиваемых дружественных для указанных базовых классов операторов сложения, вычитания, умножения, деления, префиксного и постфиксного инкремента и декремента дробей соответственно. Реализуйте производный класс \lstinline{Rational}, который является наследником реализации указанных базовых классов. Используйте документацию библиотеки \href{https://www.boost.org/doc/libs/1_84_0/libs/utility/doc/html/utility/utilities/operators.html}{Boost.Operators}.



\newpage\thispagestyle{empty}\pdfpageheight = 12.20in\enlargethispage{100in}

\section{06. Projects and Libraries}

{\large \textbf{06.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/06.05.hpp}{06.05}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 03.10 таким образом, чтобы реализация использовала заголовочный файл и соответствующий ему дополнительный файл исходного кода вместо одного файла исходного кода. Создайте заголовочный файл, содержащий определение класса \lstinline{Rational}, файл исходного кода, содержащий реализации некоторых функций-членов класса \lstinline{Rational}, и файл исходного кода, содержащий реализацию функции \lstinline{main} с тестами и демонстрационными примерами. Реализуйте защиту от повторого включения заголовочного файла на основе директивы препроцессора \lstinline{pragma}. Реализуйте небольшие функции-члены класса \lstinline{Rational} в определении класса \lstinline{Rational} в заголовочном файле. Не используйте предкомпилированные заголовочные файлы. Не используйте глобальные объекты. Не используйте внутреннее связывание. Продемонстрируйте и объясните основные разновидности ошибок, которые могут возникунуть на этапе компоновки.

\bigskip

{\large \textbf{06.02} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/06.13.cxx}{06.13}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 06.01 таким образом, чтобы реализация использовала модуль вместо заголовочного файла и соответствующего ему файла исходного кода. Создайте юнит интерфейса моду-

ля, содержащий определение класса \lstinline{Rational}, юнит реализации модуля, содержащий реализации некоторых функций-членов класса \lstinline{Rational}, и файл исходного кода, содержащий реализацию функции \lstinline{main} с тестами и демонстрационными примерами. Используйте модули вместо заголовочных файлов стандартной библиотеки. Поместите класс \lstinline{Rational} и остальные реализованные компоненты в собственное пространство имен. Используйте одиночный, групповой экспорт или экспорт пространства имен при экспорте символов из модуля. Не используйте подмодули. Продемонстрируйте и объясните способ организации модулей на основе разделов.

\bigskip

{\large \textbf{06.03} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/06.16.cpp}{06.16}\,)}}

\bigskip

Сравните время сборки Вашего предыдущего решения задачи 06.01 и время сборки Вашего предыдущего ре-

шения задачи 06.02. Определите время сборки каждого объектного файла, время компоновки объектных файлов и полное время сборки обоих решений. Используйте команду time для измерения времени. Используйте флаг компилятора -c для сборки объектных файлов. Добавьте дополнительные заголовочные файлы стандартной библиотеки в Ваши решения. Определите размер каждого объектного файла и полный размер испол-

няемого файла каждого решения. Прочитайте \href{https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1441r1.pdf}{статью}, в которой приводятся результаты подобного сравнения.

\bigskip

{\large \textbf{06.04} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/education.sh}{education.sh}\,)}}

\bigskip

Выполните автоматизированную сборку всех примеров из репозитория \href{https://github.com/i-s-m-mipt/Education/tree/master}{Education}. Установите глобально библиотеки \href{https://www.boost.org/}{Boost} версии 1.85, выполнив команды из второго закомментированного блока скрипта \href{https://github.com/i-s-m-mipt/Education/blob/master/education.sh}{education.sh}. Установите систему автоматизации сборки \href{https://cmake.org/}{CMake} версии 3.28 или новее, выполнив команду sudo apt install cmake. Установите глобально дополнительные необходимые библиотеки, указанные в командах \lstinline{find_package} в файле \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/CMakeLists.txt}{CMakeLists.txt} проекта examples из репозитория Education. Используйте любые удобные открытые источники и документации библиотек на \href{https://github.com/}{GitHub} в качестве подкрепления. Обратите внимание, что большинство библиотек собираются и устанавливаются вручную из склонированных локально репозиториев, однако некоторые могут быть установлены через пакетные менеджеры. Например, библиотека \href{https://github.com/uxlfoundation/oneTBB}{TBB} устанавливается командой sudo apt install libtbb-dev. Выполните сборку только тех примеров из репозитория Education, которые используют стандартную библиотеку, Boost, TBB, \href{https://github.com/google/googletest}{Google.Test} или \href{https://github.com/google/benchmark}{Google.Benchmark}. Закомментируйте инструкции сборки остальных примеров в файле CMakeLists.txt проекта examples из репозитория Education. Выполните скрипт education.sh. Приложите в качестве результатов скриншоты терминалов, показывающих содержимое директории libraries и трех директорий output после завершения процесса сборки всех примеров.

\bigskip

{\large \textbf{06.05} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/06.17.cpp}{06.17}\,)}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/06.17.cpp}{\texttt{06.17}} таким образом, чтобы пользователь мог указывать версию динамической библиотеки и импортировать из нее необходимую функцию во время выполнения программы без прерывания работы и повторной сборки исполняемого файла. Реализуйте две динамические библиотеки с разными названиями. Реализуйте в библиотеках функции \lstinline{test} с одинаковыми сигнатурами и разными реализациями. Реализуйте в функции \lstinline{main} исполняемого файла возможность для пользователя указать версию библиотеки перед импортом функции \lstinline{test}. Используйте стандартный поток \lstinline{std::cin} для ввода через терминал названия файла динамической библиотеки. Используйте библиотеку \href{https://www.boost.org/doc/libs/latest/doc/html/boost_dll.html}{Boost.DLL} для импорта функций \lstinline{test} из динамических библиотек. Используйте систему автоматизации сборки CMake для сборки библиотек и исполняемого файла.



\newpage\thispagestyle{empty}\pdfpageheight = 12.30in\enlargethispage{100in}

\section{07. Debugging and Profiling}

{\large \textbf{07.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/07.09.cpp}{07.09}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 02.02 таким образом, чтобы реализация использовала для хранения корней опционалы и варианты вместо отдельных переменных. Реализуйте функцию \lstinline{solve} для вычисления корней, которая принимает в качестве аргументов коэффициенты a, b и c типа \lstinline{double} и возвращает опционал, содержащий вариант из одного, двух или бесконечного количества корней. Используйте стандартную оболочку \lstinline{std::optional} для представления опционала из нулевого или ненулевого количества корней. Используйте стандартную оболочку \lstinline{std::variant} для представления варианта из одного, двух или бесконечного количества корней. Используйте тип \lstinline{double} для хранения одного корня. Используйте стандартную оболочку \lstinline{std::pair} для хранения двух корней типа \lstinline{double}. Используйте стандартный тэг \lstinline{std::monostate} как тип для обозначения бесконечного количества корней. Не используйте стандартную функцию \lstinline{std::visit}.

\bigskip

{\large \textbf{07.02} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/07.11.cpp}{07.11}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 05.05 таким образом, чтобы пользователь мог обрабатывать ошибки с помощью исключений. Реализуйте класс \lstinline{Exception} для представления пользовательского исключения, который является наследником интерфейса стандартного исключения \lstinline{std::exception}. Переопределите наследуемую виртуальную функцию-член \lstinline{what} в классе \lstinline{Exception}. Генерируйте исключение типа \lstinline{Exception} в конструкторе класса \lstinline{Rational} при передаче нулевого знаменателя. Реализуйте в функции \lstinline{main} блок \lstinline{try} для перехвата исключений и обработчик \lstinline{catch} для стандартного исключения \lstinline{std::exception}, а также обработчик \lstinline{catch} для всех исключений. Используйте стандартный поток \lstinline{std::cerr} для вывода через терминал всех сообщений об ошибках. Продемонстрируйте в функции \lstinline{main} генерацию, перехват и обработку стандартных исключений \lstinline{std::bad_alloc}, \lstinline{std::bad_variant_access} и \lstinline{std::bad_optional_access}, а также стандартных исключений \lstinline{std::length_error} и \lstinline{std::out_of_range}, генерируемых функциями-членами стандартного контейнера \lstinline{std::vector}. Объясните причины генерации всех перечисленных выше стандартных исключений.

\bigskip

{\large \textbf{07.03} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/07.12.cpp}{07.12}\,)} \texttt{//} H. Sutter, Exceptional C\texttt{++}}

\bigskip

Исследуйте представленную ниже функцию. Определите в ней такие элементы, которые могут приводить к нормальному ветвлению пути выполнения или генерации некоторого исключения. Считайте, что \lstinline{Person} является пользовательским классом, а \lstinline{Status} является пользовательским перечислением с областью видимости.

\medskip

\begin{lstlisting}
  void test(Person const & person)
  {
      std::cout << "test : " << person.name() << '\n';
    
      if (person.grade() == 10 || person.salary() > 1'000'000)
      {
          save(Status::success, person.id());
      }
      else
      {
          save(Status::failure, person.id());
      }
  }
\end{lstlisting}

\bigskip

{\large \textbf{07.04} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/07.22.cpp}{07.22}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 04.01 таким образом, чтобы пользователь мог выполнять тестирование алгоритма сортировки. Используйте автоматизированные тесты на основе библиотеки \href{https://github.com/google/googletest}{Google.Test}.

\bigskip

{\large \textbf{07.05} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/07.23.cpp}{07.23}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 07.04 таким образом, чтобы пользователь мог выполнять про- 

филирование производительности алгоритма сортировки. Используйте микробенчмарки на основе библиотеки \href{https://github.com/google/benchmark}{Google.Benchmark}. Реализуйте параметризованный тест, передавая в роли аргумента пороговый размер сортируемого сегмента контейнера при выборе между алгоритмом быстрой сортировки и алгоритмом сортировки вставками. Используйте для тестирования контейнер из 10000 обратно сортированных элементов типа \lstinline{double}.



\newpage\thispagestyle{empty}\pdfpageheight = 11.45in\enlargethispage{100in}

\section{08. Number Processing}

{\large \textbf{08.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.09.cpp}{08.09}\,)} \texttt{//} H. Sutter, Exceptional C\texttt{++} Style}

\bigskip

Реализуйте систему мошеннического изменения приватного поля экземпляра некоторого класса внешним пользователем, не являющимся другом этого класса. Реализуйте класс \lstinline{Entity_v1}. Реализуйте в классе \lstinline{Entity_v1} приватное поле типа \lstinline{int}. Реализуйте класс \lstinline{Entity_v2}. Реализуйте в классе \lstinline{Entity_v2} публичное поле типа \lstinline{int}. Используйте оператор \lstinline{reinterpret_cast} для преобразования ссылки на экземпляр класса \lstinline{Entity_v1} в ссылку на экземпляр класса \lstinline{Entity_v2}. Реализуйте хотя бы одну другую систему мошеннического изменения приватного поля экземпляра некоторого класса внешним пользователем, не являющимся другом этого класса.

\bigskip

{\large \textbf{08.02} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.15.cpp}{08.15}\,)}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.15.cpp}{\texttt{08.15}} таким образом, чтобы пользователь мог брать остаток от деления, возводить в степень и вычислять абсолютное значение длинных чисел. Реализуйте в классе \lstinline{Integer} перегруженный оператор взятия остатка от деления с присваиванием. Реализуйте дружественный для класса \lstinline{Integer} перегруженный оператор взятия остатка от деления. Реализуйте в классе \lstinline{Integer} публичную функцию-член \lstinline{pow} для возведения длинного числа в целую степень типа \lstinline{unsigned int}. Реализуйте в классе \lstinline{Integer} публичные функции- члены \lstinline{sign} и \lstinline{abs} для получения знака и вычисления абсолютного значения длинного числа соответственно.

\bigskip

{\large \textbf{08.03} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.21.cpp}{08.21}\,)}}

\bigskip

Реализуйте алгоритмы вычисления целой части двоичного логарифма положительных чисел типа \lstinline{int} и типа \lstinline{float}. Предполагайте, что оба этих типа имеют размер 4 байта. Используйте значения типа \lstinline{unsigned int} для выполнения побитовых операций. Используйте оператор \lstinline{static_cast} для явного преобразования числа типа \lstinline{int} к значению типа \lstinline{unsigned int} и объединение \lstinline{union} для явного преобразования числа типа \lstinline{float} к значению типа \lstinline{unsigned int}. Используйте цикл \lstinline{while} и оператор побитового сдвига вправо для поиска старшего ненулевого бита в значении типа \lstinline{unsigned int}. Рассматривайте представление числа типа \lstinline{float} в соответствии со стандартом IEEE 754. Рассматривайте как нормализованные, так и денормализованные числа типа \lstinline{float}. Учитывайте, что экспонента числа типа \lstinline{float} имеет смещение на 127, которое обеспечивает хранение отрицательных степеней без знакового бита. Учитывайте, что максимальное значение экспоненты числа типа \lstinline{float} используется для представления значения бесконечности inf и неопределенного значения\,nan.

\bigskip

{\large \textbf{08.04} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.28.cpp}{08.28}\,)} \texttt{//} M. Bancila, The Modern C\texttt{++} Challenge}

\bigskip

Реализуйте алгоритм эволюции Ричарда Докинза, описанный им в третьей главе книги Слепой часовщик. Сгенерируйте начальную строку из 23 случайных букв. Сгенерируйте 100 копий начальной строки, заменяя каждую букву начальной строки другой случайной буквой с вероятностью 0.05. Вычислите для каждой из 100 сгенерированных строк значение метрики, показывающей посимвольное расхождение сгенерированной строки и целевой строкой methinksitislikeaweasel. Завершите работу алгоритма, если для любой из 100 сгенерированных строк значение метрики оказалось равным 0, в противном случае выберите любую сгенерированную строку с наименьшим значением метрики в качестве новой начальной строки и повторите итерацию алгоритма. Используйте только строчные буквы английского алфавита. Используйте стандартный источник энтропии \lstinline{std::random_device}. Используйте стандартный генератор \lstinline{std::default_random_engine}. Используйте стандартное распределение \lstinline{std::uniform_real_distribution}. Используйте стандартный поток \lstinline{std::cout} для вывода через терминал начальных строк на всех итерациях алгоритма эволюции и конечной целевой строки.

\bigskip

{\large \textbf{08.05} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.37.cpp}{08.37}\,)}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.37.cpp}{\texttt{08.37}} таким образом, чтобы пользователь мог проводить серии измерений временных интервалов с последующим усреднением. Реализуйте в классе \lstinline{Timer} публичные функции-члены \lstinline{start} и \lstinline{stop} для запуска и остановки каждого измерения. Реализуйте в классе \lstinline{Timer} приватное поле типа \lstinline{bool} для проверки и обновления состояния таймера в функциях-членах \lstinline{start} и \lstinline{stop}. Реализуйте в классе \lstinline{Timer} приватный стандартный контейнер \lstinline{std::vector} для хранения стандартных интервалов \lstinline{std::chrono::duration} с типом \lstinline{double} в качестве первого параметра шаблона, соответствующих отдельным измерениям. Реализуйте в классе \lstinline{Timer} публичную функцию-член \lstinline{average} для вычисления и получения среднего значения времени в секундах.



\newpage\thispagestyle{empty}\pdfpageheight = 15.00in\enlargethispage{100in}

\section{09. Memory Management}

{\large \textbf{09.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/09.01.cpp}{09.01}\,)}}

\bigskip

Реализуйте класс \lstinline{Tracer} для представления трассировщика вызовов функций. Реализуйте в классе \lstinline{Tracer} пользовательский конструктор по умолчанию и пользовательский деструктор, которые будут выводить парные сообщения. Используйте паттерн RAII. Предполагайте, что пользователь самостоятельно создает экземпляр класса \lstinline{Tracer} в начале каждой собственной функции. Используйте стандартный поток \lstinline{std::cout} для вывода через терминал всех сообщений. Используйте стандартную утилиту \lstinline{std::source_location} для вывода дополнительной информации в сообщениях. Реализуйте функциональный макрос \lstinline{trace} по аналогии со стандартным макросом \lstinline{assert}, который позволит отключить всю трассировку при определении макроса \lstinline{NDEBUG}.

\bigskip

{\large \textbf{09.02} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/09.04.cpp}{09.04}\,)}}

\bigskip

Реализуйте систему управления всей памятью некоторого составного объекта при наличии у пользователя доступа только к части данного объекта. Реализуйте структуру \lstinline{Entity}. Реализуйте в структуре \lstinline{Entity} два поля типа \lstinline{int}. Используйте стандартный указатель \lstinline{std::shared_ptr} для управления всей памятью некоторого экземпляра структуры \lstinline{Entity} и обеспечения доступа только к одному из полей данного экземпляра. Не изобретайте велосипед заново. Используйте особенный конструктор стандартного указателя \lstinline{std::shared_ptr}.

\bigskip

{\large \textbf{09.03} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/09.06.cpp}{09.06}\,)}}

\bigskip

Реализуйте класс \lstinline{Tree} для представления бинарного дерева. Реализуйте структуру \lstinline{Node} для представления узлов бинарного дерева как публичную вложенную структуру в классе \lstinline{Tree}. Реализуйте в структуре \lstinline{Node} поле типа \lstinline{int} для хранения значения текущего узла дерева, два стандартных указателя \lstinline{std::shared_ptr} для хранения адресов правого и левого дочерних узлов и стандартный указатель \lstinline{std::weak_ptr} для хранения адреса родительского узла. Реализуйте в классе \lstinline{Tree} публичный стандартный  указатель \lstinline{std::shared_ptr} для хранения адреса корневого узла дерева. Реализуйте в классе \lstinline{Tree} публичные функции-члены \lstinline{traverse_v1} и \lstinline{traverse_v2} для вывода значений всех текущих узлов дерева в окно терминала через стандартный поток \lstinline{std::cout} при обходе дерева алгоритмами поиска в ширину и поиска в глубину соответственно. Сконструируйте в функции \lstinline{main} экземпляр класса \lstinline{Tree} таким образом, чтобы дерево содержало корневой узел, два дочерних узла на промежуточном уровне и четыре дочерних узла на последнем уровне. Продемонстрируйте отсутствие неразрывных ассоциативных связей между узлами дерева и корректную работу деструкторов узлов.

\bigskip

{\large \textbf{09.04} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/09.09.cpp}{09.09}\,)}}

\bigskip

Доработайте примеры \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/05.01.cpp}{\texttt{05.01}}, \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/05.03.cpp}{\texttt{05.03}}, \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/05.09.cpp}{\texttt{05.09}}, \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/05.10.cpp}{\texttt{05.10}}, \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/05.13.cpp}{\texttt{05.13}}, \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/05.15.cpp}{\texttt{05.15}} таким образом, чтобы реализации использовали стандартные интеллектуальные указатели вместо обычных указателей. Используйте стандартные указатели \lstinline{std::shared_ptr} и \lstinline{std::unique_ptr}. Не используйте стандартный указатель \lstinline{std::weak_ptr}. Подумайте над тем, какой стандартный интеллектуальный указатель будет уместно использовать в каждом из примеров.

\bigskip

{\large \textbf{09.05} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/09.11.cpp}{09.11}\,)}}

\bigskip

Доработайте Ваше предыдущее решение задачи 04.01 таким образом, чтобы реализация использовала итераторы контейнеров вместо индексов элементов. Предполагайте, что коллекции элементов передаются в алгоритм сортировки не через ссылку на контейнер, а через копирование двух итераторов полуоткрытого диапазона начала и конца коллекции, при этом итераторы могут быть однонаправленные,~двунаправленные~или~произ- вольного доступа. Используйте стандартные функции \lstinline{std::distance}, \lstinline{std::advance}, \lstinline{std::next} и \lstinline{std::prev}.

\bigskip

{\large \textbf{09.06} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/09.15.cpp}{09.15}\,)}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/09.15.cpp}{\texttt{09.15}} таким образом, чтобы реализация использовала двунаправленные итераторы для обслуживания двусвязного списка. Реализуйте в структуре \lstinline{Node} стандартный указатель \lstinline{std::weak_ptr} для хранения адреса предыдущего узла списка. Реализуйте в классе \lstinline{Iterator} перегруженные операторы префиксного и постфиксного декремента. Дополните в классе \lstinline{List} текущую реализацию функции-члена \lstinline{push_back}.

\bigskip

{\large \textbf{09.07} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/09.16.cpp}{09.16}\,)}}

\bigskip

Реализуйте алгоритм вычисления чисел ряда Фибоначчи на основе однонаправленного итератора. Реализуйте класс \lstinline{Iterator} для представления однонаправленного итератора. Реализуйте в классе \lstinline{Iterator} два приватных поля типа \lstinline{int} для хранения двух смежных чисел ряда Фибоначчи. Реализуйте в классе \lstinline{Iterator} конструктор по умолчанию, перегруженные операторы префиксного и постфиксного инкремента, разыменования и сравнения на равенство. Реализуйте операторы инкремента таким образом, чтобы они вычисляли следующие два смежных числа ряда Фибоначчи на основе двух текущих известных чисел ряда Фибоначчи, а оператор разыменования таким образом, чтобы он возвращал последнее вычисленное число ряда Фибоначчи.



\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{10. Data Structures}

{\large \textbf{10.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/10.29.cpp}{10.29}\,)} \texttt{//} M. Bancila, The Modern C\texttt{++} Challenge}

\bigskip

Реализуйте алгоритм моделирования игры Жизнь по стандартным правилам на игровом поле размером 10 на 10 клеток. Задайте начальное состояние игрового поля случайным образом. Используйте стандартный двумерный контейнер \lstinline{std::vector} для хранения текущего состояния игрового поля. Используйте стандартный поток \lstinline{std::cout} для вывода через терминал состояний игрового поля на всех итерациях моделирования игры.

\bigskip

{\large \textbf{10.02} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/10.33.cpp}{10.33}\,)}}

\bigskip

Реализуйте алгоритм вычисления N\,-\,ого числа ряда Фибоначчи на основе метода матричной экспоненциации. Используйте тип \lstinline{boost::numeric::ublas::matrix} для осуществления вычислений с матрицами. Реализуйте алгоритм быстрого возведения начальной матрицы в степень N. Используйте тип \lstinline{usigned long long int} для значений элементов матриц. Обоснуйте алгоритмическую сложность реализованного алгоритма и сравните ее с алгоритмической сложностью других известных Вам алгоритмов вычисления N\,-\,ого числа ряда Фибоначчи.



\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{11. Algorithms and Ranges}

{\large \textbf{11.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/11.01.cpp}{11.01}\,)} \texttt{//} H. Sutter, Exceptional C\texttt{++}}

\bigskip

Реализуйте функцию, которая возвращает указатель на саму себя так, чтобы можно было написать следующее: \lstinline{Wrapper function = test(); (*function)();} Используйте класс с перегруженным оператором приведения.

\bigskip

{\large \textbf{11.02} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/11.08.cpp}{11.08}\,)}}

\bigskip

Сравните среднее время вызова лямбда\,-\,функции, сохраненной в переменной с местозаменителем типа \lstinline{auto}, и среднее время вызова той же самой лямбда\,-\,функции, сохраненной в стандартной оболочке \lstinline{std::function}.

\bigskip

{\large \textbf{11.03} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/11.27.cpp}{11.27}\,)}}

\bigskip

Реализуйте алгоритм решения задачи коммивояжера для полносвязного графа, содержащего 10 вершин. Используйте тип \lstinline{int} для значений весов ребер графа. Инициализируйте веса всех ребер графа случайными значениями от 1 до 10. Используйте стандартный двумерный контейнер \lstinline{std::vector} в качестве симметричной относительно главной диагонали матрицы инцидентности для хранения весов ребер графа. Используйте стандартный алгоритм \lstinline{std::next_permutation} для перебора всех перестановок последовательности обхода вершин, включающей в себя каждую вершину графа только один раз. Учтите, что обход вершин графа должен завершаться в начальной вершине. Используйте стандартный поток \lstinline{std::cout} для вывода через терминал матрицы инцидентности, оптимальной последовательности обхода вершин, а также ее суммарной стоимости.



\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{12. String Processing}

{\large \textbf{12.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/12.02.cpp}{12.02}\,)}}

\bigskip

Напишите программу, которая выводит собственный исходный код в окно терминала через стандартный поток \lstinline{std::cout}. Не используйте файловые потоки ввода. Предполагайте, что файл с исходным кодом недоступен.



\newpage\thispagestyle{empty}\pdfpageheight = 1.00in\enlargethispage{100in}

\section{13. Streams and Serialization}



\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{14. Parallel Programming}

{\large \textbf{14.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/14.09.cpp}{14.09}\,)}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/14.09.cpp}{\texttt{14.09}} таким образом, чтобы реализация использовала передаваемый пользователем вызываемый объект и применяла его ко всем элементам коллекции вместо вычисления суммы с помощью стандартной политики \lstinline{std::plus}. Сравните тип возвращаемого результата реализованного параллельного алгоритма с типом возвращаемого результата стандартного алгоритма \lstinline{std::for_each} без политики параллельного выполнения. Обоснуйте причины различия типов возвращаемых результатов указанных алгоритмов.

\bigskip

{\large \textbf{14.02} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/14.10.cpp}{14.10}\,)}}

\bigskip

Реализуйте систему обработки исключений, которые могут быть выброшены функциями, выполняемыми в дополнительных стандартных потоках \lstinline{std::thread}. Используйте обработчик \lstinline{catch} для перехвата всех исключений в функции дополнительного потока. Используйте стандартный указатель \lstinline{std::exception_ptr} для хранения исключения, который будет доступен в функции дополнительного потока и в функции основного потока. Используйте стандартную функцию \lstinline{std::current_exception} для получения указателя на текущее исключение в функции дополнительного потока.\,Используйте\,стандартную\,функцию\,\lstinline{std::rethrow_exception} для повторной генерации, перехвата и обработки сохраненного ранее исключения в функции основного потока.

\bigskip





\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{15. Computer Network Systems}

{\large \textbf{15.01} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/15.01.cpp}{15.01}\,)} \texttt{//} M. Bancila, The Modern C\texttt{++} Challenge}

\bigskip

Реализуйте алгоритмы шифрования и дешифрования строк, используя шифр Цезаря со сдвигом вправо на заданное количество символов. Предполагайте, что все строки состоят из строчных букв английского алфавита.

\bigskip

{\large \textbf{15.02} \texttt{(\,\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/15.02.cpp}{15.02}\,)} \texttt{//} M. Bancila, The Modern C\texttt{++} Challenge}

\bigskip

Реализуйте алгоритмы шифрования и дешифрования строк, используя шифр Виженера. Предполагайте, что все строки состоят из строчных букв английского алфавита. Реализуйте алгоритм генерации таблицы Виженера на этапе компиляции. Используйте мгновенную функцию со спецификатором \lstinline{consteval} и стандартный дву- 

мерный контейнер \lstinline{std::array} со спецификатором \lstinline{constexpr} для генерации и хранения таблицы Виженера.  

\end{document}